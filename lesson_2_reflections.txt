What happens when you initialize a repository? Why do you need to do it?

	When you initialize a repository, Git takes in hand managing this
	directory, meaning (I think) is that, Git will create an empty repository
	to manage the history of the files in the directory (if any) and so on.
	We need to initialize a repository, of course, because otherwise
	we can't make any Git command work on a normal directory.

How is the staging area different from the working directory and the repository?
What value do you think it offers?

	The staging area is a middle place, kind of, between the working directory
	and the repository. It's where we can store files that we want to commit
	but not ready to commit them yet, it's like a queue.

How can you use the staging area to make sure you have one commit per logical
change?

	Since the staging area is like a middle step between the working directory
	and the Git repository, and is able to hold more than one file at a time,
	so one knowing the logical change they've made, can collect all the files that
	were involved in that change in the staging area and then commit them together.
	Also, the git diff and git diff --staged can be very useful if we're not sure
	what changes were made to ensure that we have just one logical change per
	commit.

What are some situations when branches would be helpful in keeping your history organized? How would branches help?

	As the course mentioned, introducing a new experimental feature 
	should induce the creation of a new branch. Also, testing in general
	should always make us create a new branch. Testing these features 
	aside from the somewhat fully working program will make us at ease, 
	plus once we're ready, we can merge the branches and no harm is 
	done!

How do the diagrams help you visualize the branch structure?

What is the result of merging two branches together? Why do we represent it in
the diagram the way we do?

What are the pros and cons of Git's automatic merging vs. always doing merges
manually?
